### Мнение №1:
Проблемные места / что лучше изменить

2. App Router и границы public/private
Сейчас:

Все страницы лежат плоско в app, а доступ защищается миксом:
middleware (cookie)
AuthGuard внутри TodosPage
Navbar прячется, если не авторизован.

Лучше для шаблона:

Развести public/private структурой маршрутов:
app/(public)/login/page.tsx
app/(protected)/todos/..., app/(protected)/profile/...
app/(protected)/layout.tsx с Navbar и AuthGuard/проверкой сессии.
Тогда:
Public layout без Navbar.
Protected layout – всё, что требует авторизации.
AuthGuard можно оставить для клиентской до‑страховки, но основную защиту делать на уровне layout или middleware.

3. Auth mock – довести до «правильного» mock‑уровня
Сейчас flow довольно хороший, но:

sessionStorage хранит «сырые» данные, без zod‑валидации при чтении.
Cookies – просто флаг app_session_exists, без payload/подписи.
useAuth + AuthProvider + middleware работают вместе, но знания о сессии разбросаны.
Что доработать (в рамках mock):

В sessionStorage.get валидировать структуру сессии через zod‑схему Session (есть в типах).
Сконцентрировать логику работы сессии внутри одной сущности (entities/session или features/auth/lib/session-service) и дергать её из:
useAuth;
useSessionCookie;
возможно, SSR/route handlers в будущем.
В middleware предусмотреть простой extension:
сейчас только редирект; добавить базовый паттерн «если токен протух, очищаем cookie и ведем на login».
Это даст хороший шаблон для замены mock‑авторизации на реальную (JWT, next-auth, собственный backend).

4. DX, конфигурация и структура
next.config.ts пустой – как шаблон лучше сразу включить:
reactStrictMode: true;
базовые security‑/image‑/headers‑настройки;
experimental‑флаги (server actions и т.п., если нужны).
tsconfig:
allowJs: true – для типизированного шаблона я бы выключил, чтобы не тянуть JS.


Форматирование и линтинг:

ESLint есть, но без правил по архитектуре FSD и без автоисправления импортов.

План рефакторинга (по шагам)

Шаг 2. Перестроить app router под public/protected
Ввести группы: app/(public) и app/(protected).
Перенести /login в (public), /todos и /profile – в (protected).
В (protected)/layout.tsx:
рендерить Navbar;
вызывать AuthGuard или выполнять проверку сессии (в дальнейшем можно перевести в server‑side check).
Middleware оставить как более «низкоуровневую» защиту, но логику сделать понятной и расширяемой.

Шаг 3. Укрепить mock auth
Добавить zod‑валидацию при чтении сессии из localStorage.
Сделать один модуль, который знает:
как выглядит Session;
как она хранится в storage;
как синхронизируется с cookie.
Описать в коде (и/или README) шаг «как заменить mock на реальную авторизацию».

Шаг 4. DX и конфиги
Настроить:
next.config.ts с базовыми опциями;
обновлённый tsconfig (отключить allowJs, добавить алиасы слоёв при желании).
Ввести арх‑линтер для проверки FSD‑импортов.

Международзация
next-intl или Intlayer

sentry/nextjs для ошибок.

### Мнение №2:
Балансируем архитектуру правильно

Entities (src/entities/):

// Только фундаментальные бизнес-сущности
- Типы данных (Todo, User)
- Zod схемы для валидации  
- Базовые API endpoints (RTK Query)
- Чистые утилиты (без зависимостей от React/Redux)

Features (src/features/):

// Конкретная бизнес-логика
- Сложные хуки (useTodos, useAuth)
- Специфичные компоненты (TodoCard, LoginForm)
- Слайсы состояния (authSlice, settingsSlice)
- Бизнес-правила и преобразования данных

Shared (src/shared/):

// Переиспользуемые инфраструктурные части
- UI компоненты (Button, Input, Card)
- API абстракции
- Утилиты (cn, formatters)
- Конфигурация (routes, env)

Пример правильной структуры Todo:

Entities (src/entities/todo/):

// api/todo-api.ts - RTK Query endpoints
// model/types.ts - Todo, CreateTodoDto, UpdateTodoDto  
// model/todo-schema.ts - Zod схемы
// lib/todo-helpers.ts - чистые функции (isTodoOverdue, formatDueDate)

Features (src/features/todos/):

// model/use-todos.ts - хуки с бизнес-логикой
// ui/todo-card/ - компоненты с состоянием
// ui/todo-actions/ - компоненты действий

### Мой вопрос:

Как соблюсти разнесение частей доменного ui по всем папкам проекта entities, features, screens (screens - это переименованный pages из fsd, иначе он вызывает старый роутер), widgets, на примере todo домена по лучшим практикам и современным тенденциям?
Мне кажется тут недостаточно сделан акцент на разделение view-model

Требуется чистое архитектурное решение:
- в widgets мне кажется там не стоит ничего доменного - там должны быть просо более сложные конструкции компонентов из шаред
- большой соблазны перенести все отображение (view) в screens и там, иерархически все разложить по папкам (иначе зачем вообще этот слой, когда есть app)
- слой entity мне кажется больше про логику, ui там должно радикально сократиться
- непонятно соотношение screens и features - не дублируются ли они, нужно четкое разграничени по целям этих слоев, чтобы потом не путаться
- не слишком ли rtk query сцеплен с доменной логикой, мне кажется он должен быть несколько обособлен, что бы, к примеру была возможность сменить на другую библиотеку и это не было бы трагедией для проекта (хотя такое пока и не предпологается)
- главное что бы архитектура была бы масштабируемой и не слишком завязанной на конккретные технологии , но не за счет перегружения абстракциями. Абстракции должны не затенять восприятие, а наоборот облегчать и делать код читабельным

Нужно провести жесткий ревьювинг по этим проблемным вопросам, и порекомендовать решения по рефакторингу по лучшим практикам и только современным тенденциям. Что бы привести проект к эталонному, готовому стать образцом для построения на его основе других профессиональных, продакшен реди решений. Особый упор на архитектуру, масштабируемость.
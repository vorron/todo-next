import { createPublicPathGuard, createProtectedPathGuard, createAuthGuard } from './guards';
import { createDynamicPath } from './utils';
import {
  routeConfigData,
  dynamicRouteConfigData,
  statefulRouteConfigData,
  TITLE_POSTFIX,
} from '../../config/router-config';

import type { NavItem } from './config-types';
import type { Metadata } from 'next';

// === Static Paths ===
export const paths = Object.fromEntries(
  Object.entries(routeConfigData).map(([key, config]) => [key, config.path]),
) as Record<keyof typeof routeConfigData, string>;

// === Dynamic Paths ===
export const dynamicPaths = Object.fromEntries(
  Object.entries(dynamicRouteConfigData).map(([key, config]) => [
    key,
    (id: string) => createDynamicPath(config.path, { id }),
  ]),
) as Record<keyof typeof dynamicRouteConfigData, (id: string) => string>;

// === Stateful Routes ===
export const statefulRoutes = Object.fromEntries(
  Object.entries(statefulRouteConfigData).map(([key, config]) => [
    key,
    {
      basePath: config.path,
      defaultState: config.defaultState,
      syncWithUrl: config.syncWithUrl,
      getStatePath: (state: string, data?: Record<string, string>) => {
        const stateConfig = config.states[state as keyof typeof config.states];
        const pattern = stateConfig.urlPattern || config.path;
        
        if (data && pattern.includes(':')) {
          return pattern.replace(/:([^/]+)/g, (_, param) => data[param] || `:${param}`);
        }
        
        return pattern;
      },
      getAvailableStates: () => Object.keys(config.states),
      isStateAvailable: (state: string) => state in config.states,
    },
  ]),
);

// === Combined Routes ===
export const routes = { ...paths, ...dynamicPaths, ...statefulRoutes } as const;

// === Navigation ===
type NavigationItem = {
  label: string;
  href: string;
  requiresAuth: boolean;
  hideWhenAuthenticated?: boolean;
  order?: number;
};

export const navigationConfig = Object.fromEntries(
  Object.entries(routeConfigData)
    .filter(([_, config]) => 'navigation' in config && config.navigation)
    .map(([key, config]) => [
      key,
      {
        label: config.navigation.label,
        href: config.path,
        requiresAuth: 'protected' in config && !!config.protected,
        hideWhenAuthenticated: config.navigation.hideWhenAuthenticated,
        order: config.navigation.order,
      } as NavigationItem,
    ]),
) as Record<keyof typeof routeConfigData, NavigationItem>;

// === Stateful Navigation ===
type StatefulNavigationItem = NavigationItem & {
  isStateful: true;
  states: Record<string, {
    label: string;
    href: string;
    order?: number;
  }>;
};

export const statefulNavigationConfig = Object.fromEntries(
  Object.entries(statefulRouteConfigData).map(([key, config]) => [
    key,
    {
      label: config.navigation?.label || key,
      href: config.path,
      requiresAuth: config.protected,
      order: config.navigation?.order,
      hideWhenAuthenticated: config.navigation?.hideWhenAuthenticated,
      isStateful: true,
      states: Object.fromEntries(
        Object.entries(config.states).map(([stateKey, stateConfig]) => {
          const navConfig = stateConfig.navigation;
          return [
            stateKey,
            {
              label: navConfig?.label ?? stateKey,
              href: stateConfig.urlPattern ?? config.path,
              order: navConfig?.order,
            },
          ];
        }),
      ),
    } satisfies StatefulNavigationItem,
  ]),
) as Record<keyof typeof statefulRouteConfigData, StatefulNavigationItem>;

// === Main Navigation ===
export const mainNavigation = [
  ...Object.values(navigationConfig)
    .filter((item) => !item.hideWhenAuthenticated)
    .sort((a, b) => (a.order ?? 999) - (b.order ?? 999)),
  ...Object.values(statefulNavigationConfig)
    .filter((item) => !item.hideWhenAuthenticated)
    .filter((statefulItem) => 
      !Object.values(navigationConfig).some((staticItem) => staticItem.href === statefulItem.href)
    )
    .sort((a, b) => (a.order ?? 999) - (b.order ?? 999))
    .map(({ states, ...item }) => item),
];

// === Metadata ===
type StatefulMetadataItem = {
  base: { title: string };
  states: Record<string, (data?: unknown) => Metadata>;
};

export const statefulMetadataConfig = Object.fromEntries(
  Object.entries(statefulRouteConfigData).map(([key, config]) => [
    key,
    {
      base: {
        ...config.metadata,
        title: `${config.metadata.title}${TITLE_POSTFIX}`,
      },
      states: Object.fromEntries(
        Object.entries(config.states).map(([stateKey, stateConfig]) => {
          if (stateConfig.metadata) {
            return [
              stateKey,
              (data?: unknown) => {
                const metadata = stateConfig.metadata(data);
                return {
                  ...metadata,
                  title: `${metadata.title}${TITLE_POSTFIX}`,
                };
              },
            ];
          }
          return [
            stateKey,
            () => ({
              ...config.metadata,
              title: `${config.metadata.title}${TITLE_POSTFIX}`,
            }),
          ];
        }),
      ),
    } satisfies StatefulMetadataItem,
  ]),
) as Record<keyof typeof statefulRouteConfigData, StatefulMetadataItem>;

export const metadataConfig = {
  ...Object.fromEntries(
    Object.entries(routeConfigData).map(([, config]) => [
      config.path,
      {
        ...config.metadata,
        title: `${config.metadata.title}${TITLE_POSTFIX}`,
      },
    ]),
  ),
  ...Object.fromEntries(
    Object.entries(statefulRouteConfigData).map(([, config]) => [
      config.path,
      {
        ...config.metadata,

// === Dynamic Metadata ===
export const dynamicMetadata = Object.fromEntries(
  Object.entries(dynamicRouteConfigData).map(([key, config]) => [
    key,
    (title: string): Metadata => ({
      ...config.metadata(title),
      title: `${config.metadata(title).title}${TITLE_POSTFIX}`,
    }),
  ]),
) as Record<keyof typeof dynamicRouteConfigData, (title: string) => Metadata>;

// === Protected Patterns ===
export const protectedPatterns = [
  ...Object.values(dynamicRouteConfigData).map((config) => config.path),
  ...Object.values(statefulRouteConfigData).map((config) => config.path),
];

export const protectedPatternsArray = protectedPatterns.map((pattern) =>
  new RegExp(`^${pattern.replace(/:[^/]+/g, '([^/]+)')}$`)
);

// === Guards ===
export const isPublicPath = (path: string): boolean =>
  !protectedPatterns.some((pattern) => path.startsWith(pattern));

export const isProtectedPath = (path: string): boolean =>
  protectedPatterns.some((pattern) => path.startsWith(pattern));

export const requiresAuth = (path: string): boolean => isProtectedPath(path);

// === Types ===
export type { RouteKey, DynamicRouteKey, AllRouteKey, StatefulRouteKey } from './config-types';

// Переопределяем типы с реальными данными для строгой типизации
type RouteConfigData = typeof routeConfigData;
type DynamicRouteConfigData = typeof dynamicRouteConfigData;
type StatefulRouteConfigData = typeof statefulRouteConfigData;

export type StrictRouteKey = keyof RouteConfigData;
export type StrictDynamicRouteKey = keyof DynamicRouteConfigData;
export type StrictStatefulRouteKey = keyof StatefulRouteConfigData;
export type StrictAllRouteKey = StrictRouteKey | StrictDynamicRouteKey | StrictStatefulRouteKey;

// === Generated Utility Types ===
export type HeaderTemplateKey = keyof typeof headerTemplates;
export type MetadataKey = keyof typeof metadataConfig;
export type NavConfigKey = keyof typeof navigationConfig | keyof typeof statefulNavigationConfig;
export type StatefulKey = keyof typeof statefulRouteConfigData;
